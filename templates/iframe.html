<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
$pwa_head
<title>$name â€” OpenPortal</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { height: 100dvh; height: 100vh; overflow: hidden; }
  body {
    height: 100dvh;
    height: 100vh;
    overflow: hidden;
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
    padding-top: env(safe-area-inset-top);
  }
  @supports (height: 100dvh) {
    html, body { height: 100dvh; }
  }
  .toolbar {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem 0.75rem;
    background: #141414;
    border-bottom: 1px solid #262626;
    flex-shrink: 0;
    font-family: system-ui, -apple-system, sans-serif;
  }
  .toolbar a:not(.toolbar-link) {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.35rem 0.7rem;
    border-radius: 6px;
    background: #262626;
    color: #e5e5e5;
    text-decoration: none;
    font-size: 0.8rem;
    font-weight: 600;
    white-space: nowrap;
  }
  .toolbar a:not(.toolbar-link):hover { background: #333; }
  .toolbar-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
    flex: 1;
  }
  .toolbar-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: #e5e5e5;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .toolbar-meta {
    font-size: 0.75rem;
    color: #737373;
    white-space: nowrap;
  }
  .toolbar-status {
    color: #22c55e;
  }
  .toolbar-stats {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.7rem;
    color: #737373;
    white-space: nowrap;
    font-variant-numeric: tabular-nums;
  }
  .stat-item {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
  }
  .stat-bar {
    width: 48px;
    height: 8px;
    background: #404040;
    border-radius: 4px;
    overflow: hidden;
    display: inline-block;
    vertical-align: middle;
  }
  .stat-bar-fill {
    display: block;
    height: 100%;
    border-radius: 4px;
    background: #4ade80;
    transition: width 0.5s ease, background 0.5s ease;
  }
  .stat-bar-fill.warn { background: #f59e0b; }
  .stat-bar-fill.crit { background: #ef4444; }
  .toolbar-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 34px;
    height: 34px;
    border-radius: 6px;
    background: #262626;
    color: #e5e5e5;
    text-decoration: none;
    flex-shrink: 0;
  }
  .toolbar-link:hover { background: #333; }
  .toolbar-link svg { width: 16px; height: 16px; fill: currentColor; }
  @media (max-width: 500px) {
    .toolbar-meta { display: none; }
    .toolbar-stats { display: none; }
  }
  .mic-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 34px;
    height: 34px;
    border-radius: 6px;
    background: #262626;
    color: #e5e5e5;
    border: none;
    cursor: pointer;
    flex-shrink: 0;
    transition: background 0.15s, color 0.15s;
  }
  .mic-btn:hover { background: #333; }
  .mic-btn.recording {
    background: #7f1d1d;
    color: #fca5a5;
    animation: pulse 1.2s ease-in-out infinite;
  }
  .mic-btn.transcribing {
    background: #1e3a5f;
    color: #93c5fd;
    cursor: wait;
  }
  .mic-btn.success {
    background: #14532d;
    color: #4ade80;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .mic-btn svg { width: 18px; height: 18px; fill: currentColor; }
  iframe { width: 100%; flex: 1; border: none; display: block; }
  .bottom-safe {
    flex-shrink: 0;
    height: env(safe-area-inset-bottom);
    background: #fcfcfc;
  }
</style>
</head>
<body>
<div class="toolbar">
  <a href="/dashboard">&#8592; Back</a>
  <div class="toolbar-info">
    <span class="toolbar-name">$name</span>
    <span class="toolbar-meta"><span class="toolbar-status">&#9679;</span> running &middot; $resources</span>
  </div>
  <div class="toolbar-stats" id="statsDisplay"></div>
  <a class="toolbar-link" href="$dashboard_url" target="_blank" rel="noopener" title="Open in Modal dashboard">
    <svg viewBox="0 0 24 24"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>
  </a>
  <button class="mic-btn" id="micBtn" title="Voice to clipboard">
    <svg viewBox="0 0 24 24" id="micIcon"><path d="M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3zM7 11a5 5 0 0 0 10 0h2a7 7 0 0 1-6 6.93V20h3v2H8v-2h3v-2.07A7 7 0 0 1 5 11h2z"/></svg>
  </button>
</div>
<iframe src="$tunnel_url" allow="clipboard-read; clipboard-write"></iframe>
<div class="bottom-safe"></div>

<script>
(function() {
  // --- Stats polling ---
  const SANDBOX_ID = '$sandbox_id';
  const statsEl = document.getElementById('statsDisplay');
  let statsTimer = null;

  function barClass(pct) {
    if (pct >= 90) return 'crit';
    if (pct >= 70) return 'warn';
    return '';
  }

  function statItem(label, pct, detail) {
    const cls = barClass(pct);
    return '<span class="stat-item">' + label +
      ' <span class="stat-bar"><span class="stat-bar-fill ' + cls +
      '" style="width:' + pct + '%"></span></span> ' + detail + '</span>';
  }

  async function fetchStats() {
    try {
      const resp = await fetch('/api/sandboxes/' + SANDBOX_ID + '/stats');
      if (!resp.ok) return;
      const s = resp.json ? await resp.json() : {};
      let html = '';

      if (s.cpu_pct != null) {
        html += statItem('CPU', s.cpu_pct, s.cpu_pct + '%');
      }
      if (s.ram_pct != null) {
        const used = s.ram_used_mb < 1024
          ? Math.round(s.ram_used_mb) + 'M'
          : (s.ram_used_mb / 1024).toFixed(1) + 'G';
        html += statItem('RAM', s.ram_pct, used);
      }
      if (s.gpu_util_pct != null) {
        const gmem = s.gpu_mem_used_mb < 1024
          ? Math.round(s.gpu_mem_used_mb) + 'M'
          : (s.gpu_mem_used_mb / 1024).toFixed(1) + 'G';
        html += statItem('GPU', s.gpu_util_pct, s.gpu_util_pct + '% ' + gmem);
      }

      statsEl.innerHTML = html;
    } catch (e) {
      // silently ignore fetch errors
    }
  }

  // Initial fetch + poll every 5s
  fetchStats();
  statsTimer = setInterval(fetchStats, 5000);

  // --- Voice to clipboard ---
  const btn = document.getElementById('micBtn');
  let mediaRecorder = null;
  let chunks = [];
  let recording = false;

  btn.addEventListener('click', async () => {
    if (btn.classList.contains('transcribing')) return;

    if (!recording) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        chunks = [];
        mediaRecorder = new MediaRecorder(stream, getMimeOpts());
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) chunks.push(e.data);
        };
        mediaRecorder.onstop = async () => {
          stream.getTracks().forEach(t => t.stop());
          await transcribeAndCopy();
        };
        mediaRecorder.start();
        recording = true;
        btn.classList.add('recording');
        btn.title = 'Stop recording';
      } catch (err) {
        alert('Microphone access denied: ' + err.message);
      }
    } else {
      recording = false;
      btn.classList.remove('recording');
      btn.title = 'Voice to clipboard';
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }
  });

  function getMimeOpts() {
    if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return { mimeType: 'audio/webm;codecs=opus' };
    if (MediaRecorder.isTypeSupported('audio/webm')) return { mimeType: 'audio/webm' };
    if (MediaRecorder.isTypeSupported('audio/mp4')) return { mimeType: 'audio/mp4' };
    return {};
  }

  async function transcribeAndCopy() {
    if (chunks.length === 0) return;
    btn.classList.add('transcribing');
    btn.title = 'Transcribing...';

    const mimeType = chunks[0].type || 'audio/webm';
    const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
    const blob = new Blob(chunks, { type: mimeType });
    const formData = new FormData();
    formData.append('file', blob, 'recording.' + ext);

    try {
      const resp = await fetch('/api/transcribe', {
        method: 'POST',
        body: formData,
      });
      if (!resp.ok) {
        const errText = await resp.text();
        throw new Error(errText || resp.statusText);
      }
      const data = await resp.json();
      const text = data.text || '';
      if (text) {
        await navigator.clipboard.writeText(text);
        btn.classList.add('success');
        btn.title = 'Copied to clipboard!';
        setTimeout(() => { btn.classList.remove('success'); btn.title = 'Voice to clipboard'; }, 2000);
      } else {
        btn.title = 'No speech detected';
        setTimeout(() => { btn.title = 'Voice to clipboard'; }, 2000);
      }
    } catch (err) {
      console.error('Transcription error:', err);
      btn.title = 'Error: ' + err.message;
      setTimeout(() => { btn.title = 'Voice to clipboard'; }, 3000);
    } finally {
      btn.classList.remove('transcribing');
    }
  }
})();
</script>
</body>
</html>
